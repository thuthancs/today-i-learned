# Fundamental concepts of frontend development
## How to think about UI declaratively?
- First, **define** the component's different visual states
- Second, **determine** what triggers the state changes (i.e., clicking a button, hovering over a text, or computer inputs - timeout, image loading)
- Third, **represent** the state in memory using `useState`
- Fourth, **remove** any non-essential state variables
- Finally, **connect** the event handlers to set the state
- One note from React's docs, **keep the number of states as few as possible**
## State management
### Principles for structuring state
- _Group related state_: This is especially so true in games! For example, if the snake eats the apple, I need to update the snake's total score and its position. If they change together, merge them!
- Avoid contradictions in state
- Avoid redundant state: if we can calculate info from a component's props or its existing state variables during rendering, -> should not put that info as a state.
- Avoid duplication in state
- Avoid deeply nested state
### Reducer + Context
- It is all about organizing your state and defining how the data flows between your components.
- State shouldn't contain redundant/duplicated info. For example, if the input you want from users is their full name, then the states should be `firstName` and `lastName` without another state `fullName` - this is redundant.
- Sharing state between components: when you want the state of 2 components to always change together, remove the state from both and move it to their closest common parent and pass it down to them via props (`lifting state up`).
- Preserving and resetting state: we can use `key` to override the default behavior and force a component to reset its state.
- Extracting state logic into a `reducer`: Components with many state updates spread across many even handlers can get overwhelming -> consolidate all the state updates outside the component in a single function.
- Passing data deeply with context: use `context` to avoid drop drilling when you need to pass some prop through many components or when many components need the same info. I often see it used in the app's authentication logic.
- Scaling up with reducer and context: Reducers let us consolidate a component's state update logic. Context lets us pass info deep down to other components => can combine both reducers and context to manage the state of a complex screen.
  - Parent component uses a reducer (A)
    - Other components read A's state via context (context can hold either data or a function!)
### Resources
1. https://react.dev/learn/managing-state
2. https://react.dev/learn/reacting-to-input-with-state
